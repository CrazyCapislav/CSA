{
    print("Hello world");
}

DATAMEMORY
H
E
L
L
O

W
O
R
L
D

IMEMORY
LD $ad # Загружаем первый элемент зная его адрес
CMP # Сравниваем с нуль-терминатором
JE # Если нуль-терминатор выходим из программы
OUT # Если нет то печатаем на вывод значение
INC ad # Увеличиваем счетчик адреса
JMP # Идем в начало
HLT



PRINT должен генерировать:
    В секцию данных - саму строку посимвольно с нуль-терминатором
    Далее нужно запомнить адрес первого символа и дать ему метку STR_ADR, чтобы секция команд могла к нему обратиться (Адреса команд в формате 0x0, 0x1, ... Адреса данных - 1x0, 1x1 ...)
    Секция команд:

    START_PRINT
        LD STR_ADR * \\
        ST CUR_ADR * \\
    PRINT_LOOP: \\Метка старта
        LD CUR_ADR ** \\ загружаем символ по адресу в AC
        CMP \0 # \\ Непосредественно сравниваем с нуль терминатором
        JE END_PRINT \\ Если символ - нуль-терминатор переходим к метке окончания
        ST OUT_ADR ** \\ Записываем символ в ячейку памяти отвечающую за вывод(memory-mapped)
        LD CUR_ADR * \\ Загружем значение адреса строки
        INC \\ Инкрементируем значение адреса
        ST CUR_ADR * \\ Нужно перезаписать адрес текущего символа
        JMP PRINT_LOOP \\ Переходим в начало для печати след символа
    END_PRINT:

    START_PRINT: \\Метка старта
        LD INT_ADR ** \\ загружаем число по адресу в AC
        ST OUT_ADR ** \\ Записываем число в ячейку памяти отвечающую за вывод(memory-mapped)
    END_PRINT:




    LD (адрес первого символа строки)
    CMP /0 \\Сравнение с нуль-терминатором
    JE (Адрес, в котором находится следующий PRINT) \\, Чтобы закончить при совпадении
    ST (адрес вывода) \\Сохранение в ячейку вывода
    LD (адрес вывода) \\Нужно инкрементировать адрес вывода для продолжения
    INC
    ST адрес вывода \\Сохраняем адрес вывода
    JUMP ... \\В начало для чтения следующего символа
    PRINT \\Транслируем ячейки из памяти на ВУ


PROGRAM:
    Должен иметь всё то что находится в теле и заканчиваться HLT


VariableAssignNode:
    Если int В секцию данных должно записываться значение, в секции команд должна создаваться метка со ссылкой на это значение
    Если строка, то она должна посимвольно записаться в секцию данных с нуль терминатором, в секции команд должна создаться метка со ссылкой на адрес первого символа.

FunctionCallNode:
    Так как пока поддерживается только функция input(), то реализовать надо только её

Input():
    START_INPUT:
        Используем логику объявление типа String, то есть запоминаем адрес первого символа и даем ему метку STR_ADR
        LD STR_ADR * \\ Загружаем в AC значение адреса первого символа
        ST CUR_ADR * \\Сохраняем в ячейке текущего адреса, чтобы сохранить строку последовательно
    INPUT_LOOP:
        LD IN_ADR ** \\Загружаем значение из ячейки отвечающей за ввод (memory-mapped)
        CMP "." # \\Сравниваем значение ячейки с точкой (так как использую упрощенное представление памяти ячейки могут хранить в себе символы целиком)
        JE END_INPUT \\ Если точка, то переходим в конец
        ST CUR_ADR ** \\ Записываем символ по текущему адресу
        LD CUR_ADR * \\ Загружаем значение адреса текущей строки
        INC \\ Инкрементируем значение
        ST CUR_ADR * \\ Перезаписываем значение указателя символа
        JMP INPUT_LOOP \\ Возвращаемся в начало цикла
    END_INPUT:

BinaryOpNode:
    START_BINARY_OP:
        LD LEFT_OPERAND * \\Загружаем левый операнд, если он переменная, если нет, то прямая загрузка LD LEFT_OPERAND #
        ADD RIGHT_OPERAND * \\ В случае если операнд переменная, если нет, то прямая загрузка ADD RIGHT_OPERAND #
        \\Аналогично с SUB, MUL, DIV (вычитание, умножение, деление)
        ST RESULT * \\Запись по адресу результата
    END_BINARY_OP:

IfElseNode:
    START_IF_ELSE:
    \\ Проверяются условия по типу a == c, a != c, a <= c;
    LD LEFT_OPERAND * \\ Загружаем левый операнд
    CMP CMP_OPERAND * \\Если переменная, если нет, то CMP CMP_OPERAND #
    JE IF_BODY \\  JA для >, JAE для >=, JB для <, JBE для <=, JNE для !=
    JMP ELSE_BODY \\ Переход в else
    IF_BODY:
        \\то, что в теле if
        JMP END_IF_ELSE
    ELSE_BODY:
        \\то, что в теле else
        JMP END_IF_ELSE
    END_IF_ELSE:


IfNode:
    START_IF:
    \\ Проверяются условия по типу a == c, a != c, a <= c;
        LD LEFT_OPERAND * \\ Загружаем левый операнд
        CMP CMP_OPERAND * \\Если переменная, если нет, то CMP CMP_OPERAND #
        JE IF_BODY \\  JA для >, JAE для >=, JB для <, JBE для <=, JNE для !=
        JMP END_IF \\ Переход в else
    IF_BODY:
        \\то, что в теле if
    END_IF:


n = 100;
while(n > 0){
    print(n);
    n = n - 1;
}

WhileNode:
    START_WHILE:
        LD COUNTER * \\ Загружаем счетчик
        CMP CMP_OPERAND * \\ Если переменная, если нет, то CMP CMP_OPERAND #
        JE WHILE_LOOP \\  JA для >, JAE для >=, JB для <, JBE для <=, JNE для !=
        JMP END_WHILE \\ Переход в конец
    WHILE_LOOP:
        \\ Логика тела
        LD COUNTER *
        DEC
        ST COUNTER *
        JMP WHILE_LOOP
    END_WHILE:

WhileNode(строка): \\ Пока что строка будет только из одного символа
    START_WHILE:
        LD SYM_ADR * \\ Загружаем символ
        CMP CMP_SYM * \\ Если переменная, если нет, то CMP CMP_SYM #
        JE WHILE_LOOP \\   JNE для !=
        JMP END_WHILE \\ Переход в конец
        \\ Логика тела
        JMP START_WHILE
    END_WHILE:

